PROGRAM KEPLER
IMPLICIT NONE

INTEGER, PARAMETER :: IKIND=3 ! NATIVE x87 FLOATING POINT PRECISION

REAL*10 E, M, PI, Q1, Q2, Q3, Q6, Q7, Q60, R2, R3, Q0_01, Q0_1, Q0_5, Q0_75, X

! DEVELOPED USING SILVERFROST (AKA SALFORD) FORTRAN FTN95 COMPILER BASED ON
! ORIGINAL C CODE BY MARTIN BROWN. POSSIBLY STILL SOME TYPOS IN HERE
! THIS VERSION USES NATIVE 80 BIT X87 HARDWARE PRECISION. CLUMSY SYNTAX!
! ALTER TO IKIND=3 FOR SILVERLIGHT/SALFORD FORTRAN

! THIS IS SAMPLE TOY CODE IMPLEMENTING THE ALGORITHM DESCRIBED IN THE PAPER
! "AN IMPROVED CUBIC APPROXIMATION FOR KEPLERS EQUATION" BY MARTIN T. BROWN
! ONLINE AT https://doi.org/10.1093/mnras/stad2007

! PORTED TO GCC/GFORTRAN WHERE IKIND=4,8,10,16 SO NOW PARAMETERISED

! PRINT *,REALVALUE USED DELIBERATELY AS IT ADJUSTS TO PRECISION
! SET TERMINAL WIDTH TO AT LEAST 140 CHARACTERS IF USING REAL*16

Q1 = REAL(1,IKIND)  ! NB SALFORD FORTRAN IKIND = 3 IS REAL*10
Q2 = REAL(2,IKIND)
Q3 = REAL(3,IKIND)
Q6 = Q3+Q3
Q7 = REAL(7,IKIND)
Q60 = REAL(60,IKIND)
R2 = Q1/Q2
R3 = Q1/(Q1+Q2)
Q0_1 = REAL(0.1,IKIND)
Q0_01 = Q0_1*Q0_1
Q0_5  = R2
Q0_75 = Q3/(Q2+Q2)  ! MAKE SURE CRITICAL CONSTANTS ARE FULL 80 BIT OR QUAD PRECISION

PI = Q2*Q3*ASIN(Q0_5)
PRINT *,"PI = ", PI, "PI/2 = ", PI/Q2 ! CHECK REAL*10 HAS WORKED

IF (COMMAND_ARGUMENT_COUNT()==0) THEN

 PRINT *, "CUBIC", SOLVECUBIC( Q1, Q2, Q3)
 PRINT *, "BASIC( 1, 0.57) = ", BASIC(Q1, REAL(0.57D0,IKIND))
 PRINT *, "BASIC( 0.8, 0.1) = ", BASIC(REAL(0.8D0,IKIND), Q0_1)

 CALL TESTALL(Q1, PI/Q2-Q1, .TRUE.)
 CALL TESTALL(Q1, PI-Q0_01, .FALSE.)
 CALL TESTALL(Q0_75, Q2, .FALSE.)
 CALL TESTALL(Q0_75, -Q2, .FALSE.)
 CALL TESTALL(Q0_5, -Q0_1, .FALSE.)
 CALL TESTALL(Q0_5, Q0_1, .FALSE.)
 CALL TESTALL(Q1, REAL(1.0D-9,IKIND), .FALSE.)
 PRINT *,""
 PRINT *,"USAGE: KEPLER e M N"
 PRINT *,"WHERE N = 1 BASIC(default)  2 BETTER  3 BEST  4 M+D(e,M)"
 PRINT *,"N = 5 FLM95  6  DLB15_BG"
ELSE
  CALL PARSE_COMMANDLINE()
ENDIF

CONTAINS

SUBROUTINE PARSE_COMMANDLINE()
  CHARACTER*128 BUFFER
  INTEGER IFUN, ICMD
  REAL*10 E, M
  ICMD = COMMAND_ARGUMENT_COUNT()
  IF (ICMD>0) THEN
      CALL GET_COMMAND_ARGUMENT(1, BUFFER)
      IF (ICMD==1)THEN
        READ(BUFFER,*) IFUN
        E = Q0_75
        M = Q2*Q0_75
      ELSE  
        READ(BUFFER,*) E
      
        IF (ICMD>1)THEN
          CALL GET_COMMAND_ARGUMENT(2, BUFFER)
          READ (BUFFER,*) M
          IF (ICMD==2) THEN
            IFUN=1
          ELSE
            CALL GET_COMMAND_ARGUMENT(3, BUFFER)
            READ (BUFFER,*) IFUN
            IF (IFUN>4) IFUN = 4
            IF (IFUN<1) IFUN = 1
          ENDIF    
        ENDIF
      ENDIF
      IF ( IFUN>0 .AND. IFUN<5) THEN
        CALL SIMPLETEST(IFUN, E, M, .TRUE.)       
      ENDIF
    ENDIF  
END SUBROUTINE PARSE_COMMANDLINE

REAL*10 FUNCTION MCBRT(X)
! CORRECT ONLY FOR X>0
! FASTER AND MORE ACCURATE THAN MOST SYSTEM CBRT
REAL*10 X, Y, Y3
IF (X==0)THEN
  MCBRT  = Y
ELSE
  Y = EXP(LOG(X)*R3)
  Y3 = Y*Y*Y
  MCBRT = Y +Y*(X-Y3)/(Y3+Y3+X)
ENDIF
END FUNCTION MCBRT

FUNCTION SOLVECUBIC(AA, BB, CC)
REAL*10 AA, BB, CC, A, D, R, RR, Q, S, SOLVECUBIC
A = AA*R3
Q = BB*R3-A*A
R = (A*BB-CC)*R2-A*A*A
RR = R*R; 
D = Q*Q*Q+RR
IF (RR < D*1.0E-6)THEN
  D = 2*R/(3*D**R3)*(1+5*R*R/(27*D))
ELSE
  IF (D >= 0.0) THEN
    D = SQRT(D)
    IF (R>0.0) THEN
      S = (R+D)**R3
    ELSE
      S = - ((D-R)**R3)
    ENDIF
    D = S - Q/S - A
  ELSE
    S = SQRT(-Q);
    D = R/Q/S
    R = ACOS(D)*R3
    IF (D<0) R = R + Q2*PI*R3
    D = 2.0*S*COS(R) - A
  ENDIF
ENDIF
SOLVECUBIC = D        
END FUNCTION SOLVECUBIC

FUNCTION CLASSIC_NR(E, M, EE)
REAL*10 E, EE, F, DF,S, M, CLASSIC_NR
F = M-EE+E*SIN(EE)
S = SIN(EE/Q2)
DF = Q1-E+Q2*E*S*S
IF (DF==0) THEN
ELSE  
  F = F/DF
ENDIF
CLASSIC_NR = F
END FUNCTION CLASSIC_NR

REAL*10 FUNCTION FLM95_FIXUP(E, M, EE)
! SPECIAL PADE APPROXIMATION FOR e NEAR 1 AND M SMALL
! CAUTION CONSTANTS BELOW MAY BE SUBECT TO TYPOS CHECK ORIGINAL SOURCE 

REAL*10   M, NUM, DEN,E, EE, EE2
EE2 = EE*EE

NUM = EE2*(EE2*(-EE2*1.7454287843856404E-6+4.1584640418181644E-4)-3.0956446448551138E-2)+Q1
DEN = EE2*(EE2*(EE2*(EE2*1.7804367119519884E-8+5.9727613731070647E-6)+1.0652873476684142E-3)+1.1426132130869317E-1)+Q6
FLM95_FIXUP = (Q1-E)*EE+E*EE**3*NUM/DEN
 
END FUNCTION FLM95_FIXUP

REAL*10 FUNCTION FLM95_NR(E, M, EE)

REAL*10 E, EE, F, DF,S, M
IF (E<0.95) THEN
  IF (e<0.25) THEN
    F = FLM95_FIXUP(E,M,EE)
  ELSE
F = M-EE+E*SIN(EE)
ENDIF
F = M-EE+E*SIN(E)
ENDIF
S = SIN(EE/Q2)
DF = Q1-E+Q2*E*S*S
IF (DF==0) THEN
ELSE  
  F = F/DF
ENDIF
FLM95_NR = F
END FUNCTION FLM95_NR

REAL*10 FUNCTION NRT(E, M, EE, T)
REAL*10 E, EE, RC, M, T, NRT
RC = SQRT(Q1+T*T)
IF (M*T<0.0) RC=-RC
RC = ((M-EE)*RC+E*T)/(RC-E)
NRT = RC                      
END FUNCTION NRT

REAL*10 FUNCTION HALLEYT(E, M, EE, T)
REAL*10 E, EE, R, RC, M, T, HALLEYT

RC = SQRT(Q1+T*T)
IF (M*T<0.0) RC=-RC
R = ((M-EE)*RC+E*T)/(RC-E)
HALLEYT = R/(Q1+T*R/RC/Q2)
END FUNCTION HALLEYT

REAL*10 FUNCTION D4T2(E,M,EE)
! SAMPLE TAN(E/2) DELTA_4
REAL*10 E, EE, M, U, U2, D3EN, D3ED, F, DF, DDF, DDDF
U = TAN(EE/Q2)
U2 = U*U
F = (M-EE)*(1+U2)+Q2*E*U
IF (F==0) THEN
  D4T2 = F
ELSE
  DDF = E*U
 DDDF = E-E*U2
ENDIF 
DF = 1-E +U2+E*U2
D3EN = F*DF
D3ED = DF*DF+DDF*F ! DDF RESCALED *0.5
D4T2 = F*D3ED*D3ED/(DF*D3ED*D3ED+D3EN*(D3ED*DDF+d3EN*DDDF/Q6))
END FUNCTION D4T2


FUNCTION BASIC(E, M)
REAL*10 A, B, C, E, E2, F3, M, T, BASIC
E2 = E*E
F3 = (Q60+Q3*E2)*COS(M)-E*(Q60-Q7*E2) 
A = -(Q60+Q3*E2)*SIN(M)/F3
B = Q60*(cos(M)-E)/F3
C = -Q60*SIN(M)/F3
T = SOLVECUBIC(A,B,C)
IF (T*M<0) THEN
  T=-T
  A=-Q1
ELSE
  A = Q1
ENDIF
BASIC = ATAN2(T, A)
END FUNCTION BASIC

FUNCTION BETTER(E, M)
REAL*10 A, B, C, E, E2, F3, M, PB, PC, T, BETTER
E2 = E*E
!PB = Q7 - E2*(0.122+0.0006*E2)
!PC = Q3 + E2*(0.122+0.0074*E2)
PB = 7 - E2*0.095765
PC = 3 + E2*(0.095765 + 0.004094*E2)
F3 = (Q60+PC*E2)*COS(M)-E*(Q60-PB*E2) 
A = -(Q60+PC*E2)*SIN(M)/F3
B = Q60*(cos(M)-E)/F3
C = -Q60*SIN(M)/F3
T = SOLVECUBIC(A,B,C)
IF (T*M<0) THEN
  T=-T
  A=-Q1
ELSE
  A = Q1
ENDIF
BETTER = ATAN2(T, A)
END FUNCTION BETTER

FUNCTION DD(E, M)
REAL*10 ALPHA, BETA, E, M, DD
ALPHA = 1.1529-E*(0.5261+0.3464*E)
BETA  = ALPHA*(PI/Q2+E)/(PI/Q2-E)
DD = E*(ABS(M)/(PI/Q2-E))**ALPHA*((PI-ABS(M))/(PI/Q2+E))**BETA
IF (M<0) THEN
  DD = -DD
ENDIF  
END FUNCTION DD


    
FUNCTION OBEST(E, M)
REAL*10 A, B, C, D, D2, E, E2, F3, M, PB, PC, T, OBEST
E2 = E*E
D  = DD(E,M)
D2 = D*D
D  = E*SIN(M+D)
D  = D*D
PB = Q7 - D*(0.1118-0.00306*D)
PC = Q3 + D*(0.1118+0.00265*D)
F3 = (Q60+PC*E2)*COS(M)-E*(Q60-PB*E2+D2*D2*D2/4200.0) 
A = -(Q60+PC*E2)*SIN(M)/F3
B = Q60*(cos(M)-E)/F3
C = -Q60*SIN(M)/F3
T = SOLVECUBIC(A,B,C)
IF (T*M<0) THEN
  T=-T
  A=-Q1
ELSE
  A = Q1
ENDIF
OBEST = ATAN2(T, A)
END FUNCTION OBEST

  
FUNCTION BEST(E, M)
REAL*10 A, B, C, D, D2, E, E2, F3, M, PB, PC, S, S2, T, BEST
E2 = E*E
IF (M<2.2) THEN
  IF (M>0) THEN
    A = M 
  ELSE 
    A = -M
  ENDIF
  IF (A<pi*R2-E) THEN
      D = 1-A/(PI*R2-E)
      B = 1.226 - 1.054*E
      C = -0.23 + 0.51*E
  ELSE
      D = 1-(PI-A)/(PI*R2+E)
      B = 1.236 + 0.87*E
      C = -0.367 - 2.06 *E
  ENDIF
  D2 = D*D
  D = 1 - D2*(B+C*D2)
  IF (D<0.57) D = 0
  D = D*E
  D2 = D*D
  PB = 7 - D2*(0.1118 - 0.00306*D2)
  PC = 3 + D2*(0.1118 + 0.00265 * D2)
ELSE
    D = 0
    D2 = 0
    PB = 7
    PC = 3
ENDIF
S = SIN(M/Q2)
S2 = S*S
S2 = S2+S2
S = SIN(M)
F3 = Q1/((Q60+PC*E2)*(Q1-S2)-E*(Q60-PB*E2+D2*D2*D2/4200.0))
A = -(Q60+PC*E2)*S*F3
B = Q60*(1-E-S2)*F3
C = -Q60*S*F3
T = SOLVECUBIC(A,B,C)
IF (T*M<0) THEN
  T=-T
  A=-Q1
ELSE
  A = Q1
ENDIF
BEST = ATAN2(T, A)
END FUNCTION BEST


REAL*10 FUNCTION DLB15_BG(E, M)
REAL*10 A,B,C,E, F3, BETA, GAMMA, M, X, X2
! SET GAMMA=0 TO GET BETA ONLY VERSION
BETA = 7.0-60.0/(PI*PI)
X = M/PI
X2 = X*X
GAMMA = 0.4126-0.6138*E ! APPROX FROM DLB15 PAPER
GAMMA = 3*GAMMA*X2
F3 = Q60/(3+GAMMA+E*(7-BETA*X2))
A = -(3+GAMMA)*M*F3/Q60
B = (1-E)*F3
C = -M*F3
DLB15_BG = SOLVECUBIC(A,B,C)
END FUNCTION DLB15_BG

REAL*10 FUNCTION FLM95(E, M)
REAL*10 A, B, C, E, f3, M, ALPHA
ALPHA = (Q3*PI*PI+(1.6*PI*(PI-ABS(M)))/(1+E))/(PI*PI-Q6)
F3 = Q1/(Q3*(Q1-E)+ALPHA*E)
A = -Q3*M*F3
B = Q6*ALPHA*(Q1-E)*F3
C = -Q6*ALPHA*M*F3
FLM95 = SOLVECUBIC(A,B,C)
END FUNCTION FLM95



SUBROUTINE SIMPLETEST(IFUN, E, M, TITLE)
REAL*10 E, EE, ERR, DENR, DEHT, M, SOL
INTEGER IFUN
CHARACTER*10 NAME
LOGICAL TITLE
IF (TITLE) THEN 
  PRINT *, "Name        e       M            E              EXACT-E        NR       Halley"
ENDIF
SELECT CASE(IFUN)
  CASE(1)
   EE = BASIC(E,M)
   NAME = "Basic"
  CASE(2) 
   EE = BETTER(E,M)
   NAME = "Better"
  CASE(3) 
   EE = BEST(E,M)
   NAME = "Best"
  CASE(4)
   EE = FLM95(E,M)
   NAME = "FLM95"
  CASE (5)
   EE = DLB15_BG(E,M)
   NAME="DLB_BG"
  
END SELECT          
DENR = NRT(E, M, EE, TAN(EE))
DEHT = HALLEYT(E, M, EE, TAN(EE))
SOL  = BASIC(E,M)
ERR = HALLEYT(E, M, SOL, TAN(SOL))
SOL  = SOL+ERR
SOL  = SOL + NRT(E, M, SOL, TAN(SOL))
IF (IKIND==16) SOL  = SOL + NRT(E, M, SOL, TAN(SOL)) ! QUAD PRECISION NEEDS ONE MORE
ERR  = SOL-EE
PRINT 100, NAME, E, M, EE, ERR, DENR, DEHT
100 FORMAT(A7, F6.4,1P G11.4,G21.14, G12.4, G11.3, G12.4)
IF (IKIND > 10) THEN
  PRINT *, "Eraw  = ",EE, "N_R = ", CLASSIC_NR(E, M, EE)
  PRINT *, "EXACT = ",SOL,"ERR = ", M-SOL+E*SIN(SOL) ! , CLASSIC_NR(E,M,SOL)
ENDIF 
END SUBROUTINE SIMPLETEST

SUBROUTINE TESTALL(E, M, TITLES)
REAL*10 E, M
INTEGER I
LOGICAL TITLES
DO I=1,5
  CALL SIMPLETEST(I, E, M, I==1)
END DO
END SUBROUTINE TESTALL

END PROGRAM KEPLER